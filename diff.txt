diff --git a/GNUmakefile b/GNUmakefile
index 7adb4c1..a419efb 100644
--- a/GNUmakefile
+++ b/GNUmakefile
@@ -1,4 +1,4 @@
-LAB=8
+LAB=7
 SOL=0
 RPC=./rpc
 LAB2GE=$(shell expr $(LAB) \>\= 2)
@@ -32,7 +32,7 @@ LDLIBS += $(shell test -f `gcc -print-file-name=libdl.so` && echo -ldl)
 CC = g++
 CXX = g++
 
-lab:  lab8
+lab:  lab7
 lab1: rpc/rpctest lock_server lock_tester lock_demo
 lab2: yfs_client extent_server
 lab3: yfs_client extent_server
@@ -41,7 +41,7 @@ lab5: yfs_client extent_server lock_server lock_tester test-lab-4-b\
 	 test-lab-4-c
 lab6: yfs_client extent_server lock_server test-lab-4-b test-lab-4-c
 lab7: lock_server rsm_tester
-lab8: lock_tester lock_server rsm_tester yfs_client extent_server test-lab-4-b test-lab-4-c
+lab8: lock_tester lock_server rsm_tester
 
 hfiles1=rpc/fifo.h rpc/connection.h rpc/rpc.h rpc/marshall.h rpc/method_thread.h\
 	rpc/thr_pool.h rpc/pollmgr.h rpc/jsl_log.h rpc/slock.h rpc/rpctest.cc\
@@ -183,16 +183,13 @@ l7-sol:
 		rsm_tester.pl $(rsm_files) $(hfiles4) $(rsm_tester)
 
 l8:
-	./mklab.pl 8 0 l8 GNUmakefile rsm_client.cc $(yfs_client) $(rpclib) $(rpctest)\
-		$(extent_server) $(lock_server) start.sh stop.sh test-lab-2.pl mkfs.sh\
-		$(hfiles1) $(hfiles2) $(hfiles3) $(lock_tester) $(test-lab-4-b) $(test-lab-4-c)\
-		rsm_tester.pl $(rsm_files) $(hfiles4) rsm_client.cc $(hfiles5) $(rsm_tester)
+	./mklab.pl 8 0 l8 GNUmakefile rsm_client.cc $(rpclib) $(hfiles5) rsm.cc rsm.h
 
 l8-sol:
 	./mklab.pl 8 8 l8-sol GNUmakefile test-lab-4-a.pl $(yfs_client) $(rpclib) $(rpctest)\
 		$(extent_server) $(lock_server) start.sh stop.sh test-lab-2.pl mkfs.sh\
 		$(hfiles1) $(hfiles2) $(hfiles3) $(lock_tester) $(test-lab-4-b) $(test-lab-4-c)\
-		rsm_tester.pl $(rsm_files) $(hfiles4) rsm_client.cc $(hfiles5) $(rsm_tester)
+		rsm_tester.pl $(rsm_files) $(hfiles4) rsm_client.cc $(hfiles5) 
 
 -include *.d
 
diff --git a/email.patch b/email.patch
deleted file mode 100644
index ef78e48..0000000
--- a/email.patch
+++ /dev/null
@@ -1,85 +0,0 @@
-diff --git a/config.cc b/config.cc
-index decf07d..9285e64 100644
---- a/config.cc
-+++ b/config.cc
-@@ -266,15 +266,8 @@ config::heartbeater()
-     //find the node with the smallest id
-     m = me;
-     for (unsigned i = 0; i < mems.size(); i++) {
--      std::istringstream mist(m);
--      std::istringstream memsist(mems[i]);
--      unsigned long long mbuf;
--      unsigned long long memsbuf;
--      mist >> mbuf;
--      memsist >> memsbuf;
--      if (mbuf > memsbuf) {
--        m = mems[i];
--      }
-+      if (m > mems[i])
-+	m = mems[i];
-     }
- 
-     if (m == me) {
-diff --git a/paxos.cc b/paxos.cc
-index 7b89c9d..147c107 100644
---- a/paxos.cc
-+++ b/paxos.cc
-@@ -86,7 +86,7 @@ proposer::setn()
- }
- 
- bool
--proposer::run(int instance, std::vector<std::string> c_nodes, std::string c_v)
-+proposer::run(int instance, std::vector<std::string> newnodes, std::string newv)
- {
-   std::vector<std::string> accepts;
-   std::vector<std::string> nodes;
-@@ -96,7 +96,7 @@ proposer::run(int instance, std::vector<std::string> c_nodes, std::string c_v)
- 
-   pthread_mutex_lock(&pxs_mutex);
-   printf("start: initiate paxos for %s w. i=%d v=%s stable=%d\n",
--	 print_members(c_nodes).c_str(), instance, c_v.c_str(), stable);
-+	 print_members(newnodes).c_str(), instance, newv.c_str(), stable);
-   if (!stable) {  // already running proposer?
-     printf("proposer::run: already running\n");
-     pthread_mutex_unlock(&pxs_mutex);
-diff --git a/paxos.h b/paxos.h
-index 353689a..b94ef14 100644
---- a/paxos.h
-+++ b/paxos.h
-@@ -70,8 +70,8 @@ class proposer {
- 
-   // Proposer state
-   bool stable;
--  // std::vector<std::string> c_nodes;	// nodes in this instance
--  // std::string c_v;	// value we would like to propose
-+  std::vector<std::string> c_nodes;	// nodes in this instance
-+  std::string c_v;	// value we would like to propose
-   prop_t my_n;		// number of the last proposal used in this instance
- 
-   void setn();
-diff --git a/rsm.cc b/rsm.cc
-index d738085..7aa0ecc 100644
---- a/rsm.cc
-+++ b/rsm.cc
-@@ -345,19 +345,9 @@ rsm::set_primary()
-   }
- 
-   assert(p.size() > 0);
--  std::vector<unsigned long long> memsi;
-   for (unsigned i = 0; i < p.size(); i++) {
--    std::istringstream ist(p[i]);
--    unsigned long long mem;
--    ist >> mem;
--    memsi.push_back(mem);
--  }
--  std::sort(memsi.begin(), memsi.end());
--  for (unsigned i = 0; i < memsi.size(); i++) {
--    std::stringstream sst;
--    sst << memsi[i];
--    if (isamember(sst.str(), c)) {
--      primary = sst.str();
-+    if (isamember(p[i], c)) {
-+      primary = p[i];
-       printf("set_primary: primary is %s\n", primary.c_str());
-       return;
-     }
diff --git a/fuse.cc b/fuse.cc
index 8f71912..efa9598 100644
--- a/fuse.cc
+++ b/fuse.cc
@@ -87,7 +87,6 @@ fuseserver_setattr(fuse_req_t req, fuse_ino_t ino, struct stat *attr, int to_set
 
 
 
-
 #if 1
     struct stat st;
     // You fill this in
@@ -299,6 +298,7 @@ fuseserver_mkdir(fuse_req_t req, fuse_ino_t parent, const char *name,
 		 mode_t mode)
 {
 
+
 std::cout << "void fuseserver_mkdir\n";
 
 // S_IFDIR is not set in mode, that's weird
diff --git a/lock_server_cache.cc b/lock_server_cache.cc
index 5022795..0f49c96 100644
--- a/lock_server_cache.cc
+++ b/lock_server_cache.cc
@@ -21,14 +21,14 @@ retrythread(void *x) {
     return 0;
 }
 
-lock_server_cache::lock_server_cache(class rsm *_rsm) 
-  : rsm (_rsm)
-{
-  pthread_t th;
-  int r = pthread_create(&th, NULL, &revokethread, (void *) this);
-  assert (r == 0);
-  r = pthread_create(&th, NULL, &retrythread, (void *) this);
-  assert (r == 0);
+lock_server_cache::lock_server_cache() {
+    pthread_mutex_init(&release_acquire_mutex, NULL);
+    
+    pthread_t th;
+    int r = pthread_create(&th, NULL, &revokethread, (void *) this);
+    assert (r == 0);
+    r = pthread_create(&th, NULL, &retrythread, (void *) this);
+    assert (r == 0);
 }
 
 // This method should be a continuous loop, that sends revoke
diff --git a/lock_server_cache.h b/lock_server_cache.h
index d496c7e..1eab92c 100644
--- a/lock_server_cache.h
+++ b/lock_server_cache.h
@@ -6,7 +6,6 @@
 #include "rpc.h"
 #include "lock_server.h"
 
-#include "rsm.h"
 
 struct lock_client_id_and_seqnum {
 	std::string client_id;
@@ -56,16 +55,12 @@ public:
 
 
 class lock_server_cache {
- private:
-  class rsm *rsm;
  public:
-<<<<<<< HEAD
-  lock_server_cache(class rsm *rsm = 0);
-  lock_protocol::status stat(lock_protocol::lockid_t, int &);
   int n_retries=0;
+  lock_server_cache();
   void revoker();
   void retryer();
-  // lock_protocol::status stat(int clt, lock_protocol::lockid_t lid, int &);
+  lock_protocol::status stat(int clt, lock_protocol::lockid_t lid, int &);
   lock_protocol::status acquire(int clt, std::string client_socket, lock_protocol::seqnum_t seqnum, lock_protocol::lockid_t lid, int &r);
   lock_protocol::status release(int clt, std::string client_socket, lock_protocol::seqnum_t seqnum, lock_protocol::lockid_t lid, int &r);
   lock_protocol::status subscribe(int clt, std::string client_socke, int &r);
diff --git a/rpc/connection.cc b/rpc/connection.cc
index a9b82c5..067c0b5 100644
--- a/rpc/connection.cc
+++ b/rpc/connection.cc
@@ -298,7 +298,8 @@ tcpsconn::tcpsconn(chanmgr *m1, int port, int lossytest)
 	setsockopt(tcp_, IPPROTO_TCP, TCP_NODELAY, &yes, sizeof(yes));
 
 	if(bind(tcp_, (sockaddr *)&sin, sizeof(sin)) < 0){
-        throw PortBusyException(std::string("accept_loop tcp bind error: ") + std::string(strerror(errno))); 
+		perror("accept_loop tcp bind:");
+		assert(0);
 	}
 
 	if(listen(tcp_, 1000) < 0) {
diff --git a/rpc/connection.h b/rpc/connection.h
index 5720540..ef04987 100644
--- a/rpc/connection.h
+++ b/rpc/connection.h
@@ -7,16 +7,11 @@
 #include <netinet/in.h>
 
 #include <map>
-#include <stdexcept>
 
 #include "pollmgr.h"
 
 class connection;
 
-class PortBusyException : public std::runtime_error {
-   using runtime_error::runtime_error;
-};
-
 class chanmgr {
 	public:
 		virtual bool got_pdu(connection *c, char *b, int sz) = 0;
diff --git a/rpc/rpc.cc b/rpc/rpc.cc
index 2701ba3..636abb2 100644
--- a/rpc/rpc.cc
+++ b/rpc/rpc.cc
@@ -441,30 +441,30 @@ rpcs::reg1(unsigned int proc, handler *h)
 void
 rpcs::updatestat(unsigned int proc)
 {
-	ScopedLock cl(&count_m_);
-	counts_[proc]++;
-	curr_counts_--;
-	if(curr_counts_ == 0) {
-		std::map<int, int>::iterator i;
-		printf("RPC STATS: ");
-		for (i = counts_.begin(); i != counts_.end(); i++) {
-			printf("%x %d ", i->first, i->second);
-		}
-		printf("\n");
-
-		ScopedLock rwl(&reply_window_m_);
-		std::map<unsigned int,std::list<reply_t> >::iterator clt;
-
-		unsigned int totalrep = 0, maxrep = 0;
-		for (clt = reply_window_.begin(); clt != reply_window_.end(); clt++) {
-			totalrep += clt->second.size();
-			if (clt->second.size() > maxrep)
-				maxrep = clt->second.size();
-		}
-		jsl_log(JSL_DBG_1, "REPLY WINDOW: clients %ld total reply %d max per client %d\n", 
-				reply_window_.size(), totalrep, maxrep);
-		curr_counts_ = counting_;
-	}
+  ScopedLock cl(&count_m_);
+  counts_[proc]++;
+  curr_counts_--;
+  if(curr_counts_ == 0) {
+    std::map<int, int>::iterator i;
+    printf("RPC STATS: ");
+    for (i = counts_.begin(); i != counts_.end(); i++) {
+      printf("%x %d ", i->first, i->second);
+    }
+    printf("\n");
+
+    ScopedLock rwl(&reply_window_m_);
+    std::map<unsigned int,std::list<reply_t> >::iterator clt;
+
+    unsigned int totalrep = 0, maxrep = 0;
+    for (clt = reply_window_.begin(); clt != reply_window_.end(); clt++) {
+      totalrep += clt->second.size();
+      if (clt->second.size() > maxrep)
+        maxrep = clt->second.size();
+    }
+    jsl_log(JSL_DBG_1, "REPLY WINDOW: clients %ld total reply %d max per client %d\n", 
+        reply_window_.size(), totalrep, maxrep);
+    curr_counts_ = counting_;
+  }
 }
 
 void
diff --git a/rpc/rpc.cc.rej b/rpc/rpc.cc.rej
deleted file mode 100644
index 80614bc..0000000
--- a/rpc/rpc.cc.rej
+++ /dev/null
@@ -1,146 +0,0 @@
-diff a/rpc/rpc.cc b/rpc/rpc.cc	(rejected hunks)
-@@ -99,10 +99,11 @@ void set_rand_seed()
- 
- rpcc::rpcc(sockaddr_in d, bool retrans) : 
-   dst_(d), srv_nonce_(0), bind_done_(false), xid_(1), lossytest_(0), 
--  retrans_(retrans), chan_(NULL)
-+  retrans_(retrans), reachable_(true), chan_(NULL), destroy_wait_ (false)
- {
-   assert(pthread_mutex_init(&m_, 0) == 0);
-   assert(pthread_mutex_init(&chan_m_, 0) == 0);
-+  assert(pthread_cond_init(&destroy_wait_c_, 0) == 0);
- 
-   if (retrans) {
-     set_rand_seed();
-@@ -157,9 +158,35 @@ rpcc::bind(TO to)
-   return ret;
- };
- 
-+// Cancel all outstanding calls
-+void
-+rpcc::cancel(void)
-+{
-+  ScopedLock ml(&m_);
-+  printf("rpcc::cancel: force callers to fail\n");
-+  std::map<int,caller*>::iterator iter;
-+  for(iter = calls_.begin(); iter != calls_.end(); iter++){
-+    caller *ca = iter->second;
-+
-+    jsl_log(JSL_DBG_2, "rpcc::cancel: force caller to fail\n");
-+    {
-+      ScopedLock cl(&ca->m);
-+      ca->done = true;
-+      ca->intret = rpc_const::cancel_failure;
-+      assert(pthread_cond_signal(&ca->c) == 0);
-+    }
-+  }
-+
-+  while (calls_.size () > 0) {
-+    destroy_wait_ = true;
-+    assert(pthread_cond_wait(&destroy_wait_c_,&m_) == 0);
-+  }
-+  printf("rpcc::cancel: done\n");
-+}
-+
- int
- rpcc::call1(unsigned int proc, marshall &req, unmarshall &rep,
--      TO to)
-+    TO to)
- {
- 
-   caller ca(0, &rep);
-@@ -167,11 +194,15 @@ rpcc::call1(unsigned int proc, marshall &req, unmarshall &rep,
-     ScopedLock ml(&m_);
- 
-     if ((proc != rpc_const::bind && !bind_done_) ||
--  (proc == rpc_const::bind && bind_done_)) {
-+        (proc == rpc_const::bind && bind_done_)) {
-       jsl_log(JSL_DBG_1, "rpcc::call1 rpcc has not been bound to dst or binding twice\n");
-       return rpc_const::bind_failure;
-     }
- 
-+    if (destroy_wait_) {
-+      return rpc_const::cancel_failure;
-+    }
-+
-     ca.xid = xid_++;
-     calls_[ca.xid] = &ca;
- 
-@@ -340,7 +437,7 @@ rpcc::update_xid_rep(unsigned int xid)
- 
- 
- rpcs::rpcs(unsigned int p1, int count)
--  : port_(p1), counting_(count), curr_counts_(count), lossytest_(0)
-+  : port_(p1), counting_(count), curr_counts_(count), lossytest_(0), reachable_ (true)
- {
-   assert(pthread_mutex_init(&procs_m_, 0) == 0);
-   assert(pthread_mutex_init(&count_m_, 0) == 0);
-@@ -373,10 +470,15 @@ rpcs::~rpcs()
- bool
- rpcs::got_pdu(connection *c, char *b, int sz)
- {
-+        if (!reachable_) {
-+            jsl_log(JSL_DBG_1, "rpcss::got_pdu: not reachable\n");
-+            return true;
-+        }
-+
-   djob_t *j = new djob_t(c, b, sz);
-   c->incref();
-   bool succ = dispatchpool_->addObjJob(this, &rpcs::dispatch, j);
--  if (!succ) {
-+  if (!succ || !reachable_) {
-     c->decref();
-     delete j;
-   }
-@@ -400,9 +502,12 @@ rpcs::updatestat(unsigned int proc)
-   curr_counts_--;
-   if(curr_counts_ == 0) {
-     std::map<int, int>::iterator i;
-+    printf("RPC STATS: ");
-     for (i = counts_.begin(); i != counts_.end(); i++) {
--      jsl_log(JSL_DBG_1, "RPC STATS: %x %d\n", i->first, i->second);
-+      printf("%x %d ", i->first, i->second);
-     }
-+    printf("\n");
-+
-     ScopedLock rwl(&reply_window_m_);
-     std::map<unsigned int,std::list<reply_t> >::iterator clt;
- 
-@@ -410,10 +515,10 @@ rpcs::updatestat(unsigned int proc)
-     for (clt = reply_window_.begin(); clt != reply_window_.end(); clt++) {
-       totalrep += clt->second.size();
-       if (clt->second.size() > maxrep)
--  maxrep = clt->second.size();
-+        maxrep = clt->second.size();
-     }
-     jsl_log(JSL_DBG_1, "REPLY WINDOW: clients %ld total reply %d max per client %d\n", 
--      reply_window_.size(), totalrep, maxrep);
-+        reply_window_.size(), totalrep, maxrep);
-     curr_counts_ = counting_;
-   }
- }
-@@ -915,6 +1020,24 @@ unmarshall::rawbytes(std::string &ss, unsigned int n)
-   }
- }
- 
-+marshall &
-+operator<<(marshall &m, unsigned long x)
-+{
-+  if(sizeof(unsigned long) == sizeof(unsigned int))
-+    return m << (unsigned int) x;
-+  if(sizeof(unsigned long) == sizeof(unsigned long long))
-+    return m << (unsigned long long) x;
-+}
-+
-+unmarshall &
-+operator>>(unmarshall &u, unsigned long &x)
-+{
-+  if(sizeof(unsigned long) == sizeof(unsigned int))
-+    return u >> (unsigned int &) x;
-+  if(sizeof(unsigned long) == sizeof(unsigned long long))
-+    return u >> (unsigned long long &) x;
-+}
-+
- bool operator<(const sockaddr_in &a, const sockaddr_in &b) {
-   return ((a.sin_addr.s_addr < b.sin_addr.s_addr) ||
-     ((a.sin_addr.s_addr == b.sin_addr.s_addr) &&
diff --git a/rsm.cc b/rsm.cc
index ca6881c..ff93483 100644
--- a/rsm.cc
+++ b/rsm.cc
@@ -83,7 +83,6 @@
 
 #include "handle.h"
 #include "rsm.h"
-#include "rsm_client.h"
 
 static void *
 recoverythread(void *x)
@@ -133,13 +132,6 @@ rsm::rsm(std::string _first, std::string _me)
   assert(pthread_mutex_unlock(&rsm_mutex)==0);
 }
 
-void
-rsm::reg1(int proc, handler *h)
-{
-  assert(pthread_mutex_lock(&rsm_mutex)==0);
-  procs[proc] = h;
-  assert(pthread_mutex_unlock(&rsm_mutex)==0);
-}
 
 // The recovery thread runs this function
 void
@@ -191,28 +183,7 @@ rsm::sync_with_primary()
 bool
 rsm::statetransfer(std::string m)
 {
-  rsm_protocol::transferres r;
-  handle h(m);
-  int ret;
-  printf("rsm::statetransfer: contact %s w. my last_myvs(%d,%d)\n", 
-	 m.c_str(), last_myvs.vid, last_myvs.seqno);
-  if (h.get_rpcc()) {
-    assert(pthread_mutex_unlock(&rsm_mutex)==0);
-    ret = h.get_rpcc()->call(rsm_protocol::transferreq, cfg->myaddr(), 
-			     last_myvs, r, rpcc::to(1000));
-    assert(pthread_mutex_lock(&rsm_mutex)==0);
-  }
-  if (h.get_rpcc() == 0 || ret != rsm_protocol::OK) {
-    printf("rsm::statetransfer: couldn't reach %s %lx %d\n", m.c_str(), 
-	   (long unsigned) h.get_rpcc(), ret);
-    return false;
-  }
-  if (stf && last_myvs != r.last) {
-    stf->unmarshal_state(r.state);
-  }
-  last_myvs = r.last;
-  printf("rsm::statetransfer transfer from %s success, vs(%d,%d)\n", 
-	 m.c_str(), last_myvs.vid, last_myvs.seqno);
+  // For lab 8
   return true;
 }
 
@@ -270,21 +241,6 @@ rsm::commit_change()
 }
 
 
-std::string
-rsm::execute(int procno, std::string req)
-{
-  printf("execute\n");
-  handler *h = procs[procno];
-  assert(h);
-  unmarshall args(req);
-  marshall rep;
-  std::string reps;
-  rsm_protocol::status ret = h->fn(args, rep);
-  marshall rep1;
-  rep1 << ret;
-  rep1 << rep.str();
-  return rep1.str();
-}
 
 //
 // Clients call client_invoke to invoke a procedure on the replicated state
@@ -323,11 +279,7 @@ rsm::transferreq(std::string src, viewstamp last, rsm_protocol::transferres &r)
 {
   assert(pthread_mutex_lock(&rsm_mutex)==0);
   int ret = rsm_protocol::OK;
-  printf("transferreq from %s (%d,%d) vs (%d,%d)\n", src.c_str(), 
-	 last.vid, last.seqno, last_myvs.vid, last_myvs.seqno);
-  if (stf && last != last_myvs) 
-    r.state = stf->marshal_state();
-  r.last = last_myvs;
+  // For lab 8
   assert(pthread_mutex_unlock(&rsm_mutex)==0);
   return ret;
 }
@@ -500,16 +452,6 @@ rsm::breakpoint2()
   }
 }
 
-void 
-rsm::partition1()
-{
-  if (dopartition) {
-    net_repair_wo(false);
-    dopartition = false;
-    partitioned = true;
-  }
-}
-
 rsm_test_protocol::status
 rsm::breakpointreq(int b, int &r)
 {
diff --git a/rsm.h b/rsm.h
index d81aac5..9050210 100644
--- a/rsm.h
+++ b/rsm.h
@@ -13,8 +13,6 @@
 
 
 class rsm : public config_view_change {
- private:
-  void reg1(int proc, handler *);
  protected:
   std::map<int, handler *> procs;
   config *cfg;
@@ -53,7 +51,6 @@ class rsm : public config_view_change {
   pthread_cond_t sync_cond;
   pthread_cond_t join_cond;
 
-  std::string execute(int procno, std::string req);
   rsm_client_protocol::status client_invoke(int procno, std::string req, 
               std::string &r);
   bool statetransfer(std::string m);
@@ -67,7 +64,6 @@ class rsm : public config_view_change {
   void net_repair_wo(bool heal);
   void breakpoint1();
   void breakpoint2();
-  void partition1();
  public:
   rsm (std::string _first, std::string _me);
   ~rsm() {};
@@ -77,162 +73,6 @@ class rsm : public config_view_change {
   void recovery();
   void commit_change();
 
-  template<class S, class A1, class R>
-    void reg(int proc, S*, int (S::*meth)(const A1 a1, R &));
-  template<class S, class A1, class A2, class R>
-    void reg(int proc, S*, int (S::*meth)(const A1 a1, const A2 a2, R &));
-  template<class S, class A1, class A2, class A3, class R>
-    void reg(int proc, S*, int (S::*meth)(const A1 a1, const A2 a2, 
-            const A3 a3, R &));
-  template<class S, class A1, class A2, class A3, class A4, class R>
-    void reg(int proc, S*, int (S::*meth)(const A1 a1, const A2 a2, 
-            const A3 a3, const A4 a4, R &));
-  template<class S, class A1, class A2, class A3, class A4, class A5, class R>
-    void reg(int proc, S*, int (S::*meth)(const A1 a1, const A2 a2, 
-            const A3 a3, const A4 a4, 
-            const A5 a5, R &));
 };
 
-template<class S, class A1, class R> void
-  rsm::reg(int proc, S*sob, int (S::*meth)(const A1 a1, R & r))
-{
-  class h1 : public handler {
-  private:
-    S * sob;
-    int (S::*meth)(const A1 a1, R & r);
-  public:
-  h1(S *xsob, int (S::*xmeth)(const A1 a1, R & r))
-      : sob(xsob), meth(xmeth) { }
-    int fn(unmarshall &args, marshall &ret) {
-      A1 a1;
-      R r;
-      args >> a1;
-      assert(args.okdone());
-      int b = (sob->*meth)(a1,r);
-      ret << r;
-      return b;
-    }
-  };
-  reg1(proc, new h1(sob, meth));
-}
-
-template<class S, class A1, class A2, class R> void
-  rsm::reg(int proc, S*sob, int (S::*meth)(const A1 a1, const A2 a2, R & r))
-{
- class h1 : public handler {
-  private:
-    S * sob;
-    int (S::*meth)(const A1 a1, const A2 a2, R & r);
-  public:
-  h1(S *xsob, int (S::*xmeth)(const A1 a1, const A2 a2, R & r))
-    : sob(xsob), meth(xmeth) { }
-    int fn(unmarshall &args, marshall &ret) {
-      A1 a1;
-      A2 a2;
-      R r;
-      args >> a1;
-      args >> a2;
-      assert(args.okdone());
-      int b = (sob->*meth)(a1,a2,r);
-      ret << r;
-      return b;
-    }
-  };
-  reg1(proc, new h1(sob, meth));
-}
-
-template<class S, class A1, class A2, class A3, class R> void
-  rsm::reg(int proc, S*sob, int (S::*meth)(const A1 a1, const A2 a2, 
-             const A3 a3, R & r))
-{
- class h1 : public handler {
-  private:
-    S * sob;
-    int (S::*meth)(const A1 a1, const A2 a2, const A3 a3, R & r);
-  public:
-  h1(S *xsob, int (S::*xmeth)(const A1 a1, const A2 a2, const A3 a3, R & r))
-    : sob(xsob), meth(xmeth) { }
-    int fn(unmarshall &args, marshall &ret) {
-      A1 a1;
-      A2 a2;
-      A3 a3;
-      R r;
-      args >> a1;
-      args >> a2;
-      args >> a3;
-      assert(args.okdone());
-      int b = (sob->*meth)(a1,a2,a3,r);
-      ret << r;
-      return b;
-    }
-  };
-  reg1(proc, new h1(sob, meth));
-}
-
-template<class S, class A1, class A2, class A3, class A4, class R> void
-  rsm::reg(int proc, S*sob, int (S::*meth)(const A1 a1, const A2 a2, 
-             const A3 a3, const A4 a4, R & r))
-{
- class h1 : public handler {
-  private:
-    S * sob;
-    int (S::*meth)(const A1 a1, const A2 a2, const A3 a3, const A4 a4, R & r);
-  public:
-  h1(S *xsob, int (S::*xmeth)(const A1 a1, const A2 a2, const A3 a3, 
-            const A4 a4, R & r))
-    : sob(xsob), meth(xmeth) { }
-    int fn(unmarshall &args, marshall &ret) {
-      A1 a1;
-      A2 a2;
-      A3 a3;
-      A4 a4;
-      R r;
-      args >> a1;
-      args >> a2;
-      args >> a3;
-      args >> a4;
-      assert(args.okdone());
-      int b = (sob->*meth)(a1,a2,a3,a4,r);
-      ret << r;
-      return b;
-    }
-  };
-  reg1(proc, new h1(sob, meth));
-}
-
-
-template<class S, class A1, class A2, class A3, class A4, class A5, class R> void
-  rsm::reg(int proc, S*sob, int (S::*meth)(const A1 a1, const A2 a2, 
-             const A3 a3, const A4 a4, 
-             const A5 a5, R & r))
-{
- class h1 : public handler {
-  private:
-    S * sob;
-    int (S::*meth)(const A1 a1, const A2 a2, const A3 a3, const A4 a4, 
-       const A5 a5, R & r);
-  public:
-  h1(S *xsob, int (S::*xmeth)(const A1 a1, const A2 a2, const A3 a3, 
-            const A4 a4, const A5 a5, R & r))
-    : sob(xsob), meth(xmeth) { }
-    int fn(unmarshall &args, marshall &ret) {
-      A1 a1;
-      A2 a2;
-      A3 a3;
-      A4 a4;
-      A5 a5;
-      R r;
-      args >> a1;
-      args >> a2;
-      args >> a3;
-      args >> a4;
-      assert(args.okdone());
-      int b = (sob->*meth)(a1,a2,a3,a4,a5,r);
-      ret << r;
-      return b;
-    }
-  };
-  reg1(proc, new h1(sob, meth));
-}
-
 #endif /* rsm_h */
diff --git a/rsm_client.cc b/rsm_client.cc
index 51650dc..4ab17f3 100644
--- a/rsm_client.cc
+++ b/rsm_client.cc
@@ -31,7 +31,6 @@ rsm_client::rsm_client(std::string dst)
 void
 rsm_client::primary_failure()
 {
-  // For lab 8
 }
 
 rsm_protocol::status
diff --git a/rsm_client.h b/rsm_client.h
deleted file mode 100644
index 9600ed5..0000000
--- a/rsm_client.h
+++ /dev/null
@@ -1,149 +0,0 @@
-#ifndef rsm_client_h
-#define rsm_client_h
-
-#include "rpc.h"
-#include "rsm_protocol.h"
-#include <string>
-#include <vector>
-
-
-//
-// rsm client interface.
-//
-// The client stubs package up an rpc, and then call the invoke procedure 
-// on the replicated state machine passing the RPC as an argument.  This way 
-// the replicated state machine isn't service specific; any server can use it.
-//
-
-class rsm_client {
-
-  struct primary_t {
-    rpcc *cl;
-    std::string id;
-    int nref;
-  };
-
- protected:
-  primary_t primary;
-  std::vector<std::string> known_mems;
-  pthread_mutex_t rsm_client_mutex;
-  void primary_failure();
-  bool init_members(bool send_mem_rpc);
- public:
-  rsm_client(std::string dst);
-  rsm_protocol::status invoke(int proc, std::string req, std::string &rep);
-
-  template<class R, class A1>
-    int call(unsigned int proc, const A1 & a1, R &r);
-
-  template<class R, class A1, class A2>
-    int call(unsigned int proc, const A1 & a1, const A2 & a2, R &r);
-
-  template<class R, class A1, class A2, class A3>
-    int call(unsigned int proc, const A1 & a1, const A2 & a2, const A3 & a3, 
-	     R &r);
-
-  template<class R, class A1, class A2, class A3, class A4>
-    int call(unsigned int proc, const A1 & a1, const A2 & a2, const A3 & a3, 
-	     const A4 & a4, R &r);
-
-  template<class R, class A1, class A2, class A3, class A4, class A5>
-    int call(unsigned int proc, const A1 & a1, const A2 & a2, const A3 & a3, 
-	     const A4 & a4, const A5 & a5, R &r);
-};
-
-template<class R, class A1> int
-  rsm_client::call(unsigned int proc, const A1 & a1, R & r)
-{
-  marshall m;
-  std::string rep;
-  std::string res;
-  m << a1;
-  int intret = invoke(proc, m.str(), rep);
-  unmarshall u(rep);
-  u >> intret;
-  u >> res;
-  unmarshall u1(res);
-  u1 >> r;
-  return intret;
-}
-
-template<class R, class A1, class A2> int
-  rsm_client::call(unsigned int proc, const A1 & a1, const A2 & a2, R & r)
-{
-  marshall m;
-  std::string rep;
-  std::string res;
-  m << a1;
-  m << a2;
-  int intret = invoke(proc, m.str(), rep);
-  unmarshall u(rep);
-  u >> intret;
-  u >> res;
-  unmarshall u1(res);
-  u1 >> r;
-  return intret;
-}
-
-template<class R, class A1, class A2, class A3> int
-  rsm_client::call(unsigned int proc, const A1 & a1, 
-		const A2 & a2, const A3 & a3, R & r)
-{
-  marshall m;
-  std::string rep;
-  std::string res;
-  m << a1;
-  m << a2;
-  m << a3;
-  int intret = invoke(proc, m.str(), rep);
-  unmarshall u(rep);
-  u >> intret;
-  u >> res;
-  unmarshall u1(res);
-  u1 >> r;
-  return intret;
-}
-
-template<class R, class A1, class A2, class A3, class A4> int
-  rsm_client::call(unsigned int proc, const A1 & a1, 
-		   const A2 & a2, const A3 & a3, const A4 & a4, R & r)
-{
-  marshall m;
-  std::string rep;
-  std::string res;
-  m << a1;
-  m << a2;
-  m << a3;
-  m << a4;
-  int intret = invoke(proc, m.str(), rep);
-  unmarshall u(rep);
-  u >> intret;
-  u >> res;
-  unmarshall u1(res);
-  u1 >> r;
-  return intret;
-}
-
-template<class R, class A1, class A2, class A3, class A4, class A5> int
-  rsm_client::call(unsigned int proc, const A1 & a1, 
-		   const A2 & a2, const A3 & a3, const A4 & a4, const A5 & a5,
-		   R & r)
-{
-  marshall m;
-  std::string rep;
-  std::string res;
-  m << a1;
-  m << a2;
-  m << a3;
-  m << a4;
-  m << a5;
-  int intret = invoke(proc, m.str(), rep);
-  unmarshall u(rep);
-  u >> intret;
-  u >> res;
-  unmarshall u1(res);
-  u1 >> r;
-  return intret;
-}
-
-#endif 
